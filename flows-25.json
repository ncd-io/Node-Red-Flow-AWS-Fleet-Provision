[{"id":"d2f119a8.67a0c","type":"tab","label":"Flow 6","disabled":false,"info":""},{"id":"ce8b4ad2b362ed72","type":"function","z":"d2f119a8.67a0c","name":"Provision Client","func":"node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"});\nrequire = global.get('require');\nvar mqtt = require('mqtt');\nvar fs = require('fs');\n\nvar KEY = fs.readFileSync('/root/claim_certs/client_key.pem.key');\nvar CERT = fs.readFileSync('/root/claim_certs/client_cert.pem.crt');\nvar CAfile = [fs.readFileSync('/root/claim_certs/root_cert.pem')];\n\nvar deviceID = msg.payload.device_id;\nvar claimToken;\nvar templateName = msg.payload.template_name;\n\nvar options = {\n    host: msg.payload.endpoint,\n    port: 8883,\n    protocolId: 'MQIsdp',\n    protocol: 'mqtts',\n    ca: CAfile,\n    key: KEY,\n    cert: CERT,\n    protocolVersion: 3,\n    clientId: \"Provision_Client_2\",\n    rejectUnauthorized: false\n};\nnode.warn(\"provision connecting to host: \"+options.host);\nclient  = mqtt.connect(options);\n\n/*I made these functions in order to be able to publish messages or close the client from every function node*/\n// context.global.publish=function(msg){\n//     node.warn(typeof msg.payload);\n//     if(typeof msg.payload == \"object\") payload=JSON.stringify(msg.payload);\n//     else if(typeof msg.payload == \"number\") payload=msg.payload.toString(10);\n//     else payload=msg.payload;\n//     client.publish(msg.topic,payload);\n// };\ncontext.global.closeclient=function(){\n    client.end();\n};\n\n/*Client events*/\nclient.on('connect', function () {\n    node.warn(\"Provision Connected. ClientID: \" + client.options.clientId);\n    node.status({fill:\"green\",shape:\"dot\",text:\"connected\"});\n    client.subscribe('$aws/certificates/create/json/accepted', function (err) {\n        if (!err){\n            node.warn(\"subscribed to '$aws/certificates/create/json/accepted'\");\n            client.publish('$aws/certificates/create/json', '{}');\n        }\n        else node.error(err);\n    });\n});\nclient.on('message', function (topic, message) {\n    // message is Buffer\n    payload=message.toString();\n    console.log(\"topic: \"+topic);\n    console.log(\"message: \"+payload);\n    if(payload==\"close\"){\n        node.warn(\"close\");\n        context.global.closeclient();\n    }\n    if(topic == '$aws/certificates/create/json/accepted'){\n        node.warn('cert generation successful');\n        var root = JSON.parse(payload);\n        fs.writeFile('/root/device_certs/client_cert.pem.crt', root.certificatePem, function (err) {\n            if (err) node.warn(err);\n        });\n        fs.writeFile('/root/device_certs/client_key.pem.key', root.privateKey, function (err) {\n            if (err) node.warn(err);\n        });\n        claimToken = root.certificateOwnershipToken;\n        client.subscribe('$aws/provisioning-templates/'+templateName+'/provision/json/accepted', function (err) {\n        if (!err){\n            node.warn('$aws/provisioning-templates/'+templateName+'/provision/json/accepted');\n            var msgObj = {};\n            msgObj.certificateOwnershipToken = claimToken;\n            msgObj.Parameters = {\"SerialNumber\":deviceID};\n            client.publish(\"$aws/provisioning-templates/\"+templateName+\"/provision/json\", JSON.stringify(msgObj));\n        }\n        else node.error(err);\n        });\n    }\n    if(topic == '$aws/provisioning-templates/'+templateName+'/provision/json/accepted'){\n        fs.readFile('/root/device_certs/settings.json', (err, data) => {\n            if(err){\n                node.warn(\"load settings file failed?\");\n                return null;\n            }else{\n                var settings = JSON.parse(data.toString());\n                var serverResponse = JSON.parse(payload.toString());\n                settings.device_id = serverResponse.thingName;\n                fs.writeFile('/root/device_certs/settings.json', JSON.stringify(settings), function (err) {\n                    if (err){\n                        node.warn(err);\n                        context.global.closeclient();\n                    } \n                    else{\n                        node.warn(\"Device: \"+settings.device_id+\" provisioned\");\n                        context.global.closeclient();\n                        node.send({\"payload\":\"go\"})\n                    } \n                });\n            }\n        });\n        \n    }\n});\nclient.on('close', function () {\n    node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"});\n    node.warn(\"client disconnected\");\n});\n\n/*Node implemented in order to detect a deployment, it shuts down the client. Otherwise the client keeps subscribed and running even after a deploy*/\nnode.on('close', function() {\n    node.warn(\"Deploy, closeclient\");\n    context.global.closeclient();\n});\nreturn null;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1100,"y":460,"wires":[["704c65af.4c1f3c"]]},{"id":"8243ee8c.adf298","type":"ncd-gateway-node","z":"d2f119a8.67a0c","name":"","connection":"3a674906.5b9e76","unknown_devices":0,"outputs":1,"x":630,"y":520,"wires":[["6212a41c.61f1e4","4178265d.2521f8"]]},{"id":"6212a41c.61f1e4","type":"function","z":"d2f119a8.67a0c","name":"Check Provision","func":"require = global.get('require');\nvar fs = require('fs');\nvar msg1 = {\"payload\":\"\"}\n\n\n//Check if we have Device certificates by validating device name.\nfs.readFile('/root/device_certs/settings.json', (err, data) => {\n    if(err){\n        node.warn(\"load file failed?\");\n        return null;\n    }else{\n        var settings = JSON.parse(data.toString());\n        flow.set(\"sensor_data_topic\",msg.payload);\n        if(settings.device_id != \"\"){\n            //Device is already provisioned\n            if(msg.topic == \"modem_mac\"){\n                node.send([null,{\"payload\":\"go\"},null]);\n                node.done();\n            }else{\n                if(msg.topic == \"sensor_data\"){\n                    node.send([null,null,msg]);\n                    node.done();\n                }\n            }\n        }else{\n            node.send([{\"payload\":{\"endpoint\":settings.endpoint,\"device_id\":msg.payload,\"template_name\":settings.template_name}},null,null]);\n            node.done();\n        }\n    }\n});","outputs":3,"noerr":0,"initialize":"","finalize":"","x":880,"y":520,"wires":[["ce8b4ad2b362ed72"],["704c65af.4c1f3c"],["2dec09a6.68396e"]]},{"id":"4178265d.2521f8","type":"debug","z":"d2f119a8.67a0c","name":"Sensor Packet","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":880,"y":460,"wires":[]},{"id":"2dec09a6.68396e","type":"function","z":"d2f119a8.67a0c","name":"Alter Data and Publish to Topic","func":"var newTopic = flow.get(\"sensor_data_topic\")+\"/\"+msg.payload.addr;\nvar newPayload = msg.payload;\ndelete newPayload.original;\nvar newMSG = {\"topic\":newTopic,\"payload\":newPayload};\ncontext.global.device_publish(newMSG);\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1130,"y":600,"wires":[[]]},{"id":"39f8dbe5.a81fdc","type":"debug","z":"d2f119a8.67a0c","name":"Publish Success Debug","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":1570,"y":520,"wires":[]},{"id":"704c65af.4c1f3c","type":"function","z":"d2f119a8.67a0c","name":"Device Client","func":"node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"});\nrequire = global.get('require');\nvar mqtt = require('mqtt');\nvar fs = require('fs');\n\nvar KEY = fs.readFileSync('/root/device_certs/client_key.pem.key');\nvar CERT = fs.readFileSync('/root/device_certs/client_cert.pem.crt');\nvar CAfile = [fs.readFileSync('/root/device_certs/root_cert.pem')];\nvar settings = JSON.parse(fs.readFileSync('/root/device_certs/settings.json').toString());\n\nvar deviceID = settings.device_id;\nvar endpoint = settings.endpoint;\n\nvar buffer = [];\n\nvar options = {\n    host: endpoint,\n    port: 8883,\n    protocolId: 'MQIsdp',\n    protocol: 'mqtts',\n    ca: CAfile,\n    key: KEY,\n    cert: CERT,\n    protocolVersion: 3,\n    clientId: deviceID,\n    rejectUnauthorized: false,\n    reconnectPeriod: 10000,\n    keepalive:10\n};\nnode.warn(\"device connecting to host: \"+options.host);\nclient  = mqtt.connect(options);\n\n/*I made these functions in order to be able to publish messages or close the client from every function node*/\ncontext.global.device_publish=function(msg){\n    if(!client.connected){\n      client = mqtt.connect(options);\n      buffer.push(msg);\n    }\n    if(typeof msg.payload == \"object\") payload=JSON.stringify(msg.payload);\n    else if(typeof msg.payload == \"number\") payload=msg.payload.toString(10);\n    else payload=msg.payload;\n    client.publish(msg.topic,payload,null,function(err){\n        if(err){\n            node.warn(err);\n        }else{\n            node.send(msg);\n        }\n    });\n};\ncontext.global.device_closeclient=function(){\n    client.end();\n};\n\n/*Client events*/\nclient.on('connect', function () {\n    node.warn(\"Device Connected. ClientID: \" + client.options.clientId);\n    node.status({fill:\"green\",shape:\"dot\",text:\"connected\"});\n    buffer.forEach(element => client.publish(msg.topic,msg.payload));\n});\nclient.on('message', function (topic, message) {\n    // message is Buffer\n    payload=message.toString();\n    console.log(\"topic: \"+topic);\n    console.log(\"message: \"+payload);\n});\nclient.on('close', function () {\n    node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"});\n    node.warn(\"client disconnected\");\n});\n\n/*Node implemented in order to detect a deployment, it shuts down the client. Otherwise the client keeps subscribed and running even after a deploy*/\nnode.on('close', function() {\n    node.warn(\"Deploy, closeclient\");\n    context.global.device_closeclient();\n});\nreturn null;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1290,"y":520,"wires":[["39f8dbe5.a81fdc"]]},{"id":"3a674906.5b9e76","type":"ncd-gateway-config","name":"","comm_type":"serial","ip_address":"","tcp_port":"2101","port":"/dev/ttyS1","baudRate":"115200","pan_id":"7FFF","rssi":false}]